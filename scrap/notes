--- Pre-existing ---

private_key = metamask account private key
public_key = metamask account public key
address = metamask account



--- Onboarding ---

Connect to Metamask to get address

seed = 32 random bytes

password = user chosen

iv_seed = 16 random bytes
iv_root = 16 random bytes
encryped_seed = aes_encrypt(seed, iv_seed, password)

password_salt = iv_seed + iv_root
hashed_password = hash(password, password_salt)

store encryped_seed, iv_seed, iv_root, and hashed_password in smart contract @ address account

root = metamask_sign(seed, private_key)

encrypted_root = aes_encrypt(root, iv_root, password)

keep local copy of address, encryped_seed, iv_seed, encrypted_root, iv_root, and hashed_password

use root for all password generation



--- Login ---

local already has address, encryped_seed, iv_seed, encrypted_root, iv_root, and hashed_password

password = user input

password_salt = iv_seed + iv_root
check that hashed_password == hash(password, password_salt)

root = aes_encrypt(encrypted_root, iv_root, password)

use root for all password generation



--- Restore ---

Connect to Metamask to get address

fetch encryped_seed, iv_seed, iv_root, and hashed_password from smart contract @ address account

password = user input

password_salt = iv_seed + iv_root
check that hashed_password == hash(password, password_salt)

seed = aes_decrypt(encryped_seed, iv_seed, password)

root = metamask_sign(seed, private_key)

encrypted_root = aes_encrypt(root, iv_root, password)

keep local copy of address, encryped_seed, iv_seed, encrypted_root, iv_root, and hashed_password

use root for all password generation



--- Change Password ---

already have a local copy of address, encryped_seed, iv_seed, encrypted_root, iv_root, and hashed_password (if not, restore)

old_password = user input
new_password = user input

password_salt = iv_seed + iv_root
check that hashed_password == hash(old_password)

seed = aes_decrypt(encryped_seed, iv_seed, old_password)
root = aes_decrypt(encrypted_root, iv_root, old_password)

new_iv_seed = 16 random bytes
new_iv_root = 16 random bytes

new_password_salt = new_iv_seed + new_iv_root
new_hashed_password = hash(new_password, new_password_salt)

new_encrypted_seed = aes_encrypt(seed, new_iv_seed, new_password)
new_encrypted_root = aes_encrypt(root, new_iv_root, new_password)

store new_encrypted_seed, new_iv_seed, new_iv_root, and new_hashed_password in smart contract @ address account

keep local copy of new_encrypted_seed, new_iv_seed, new_encrypted_root, new_iv_root, and hashed_password

still use root for all password generation



--- Onboard new device ---

Extension displays encrypted_root and address via QR (or via chrome storange sync, or copy paste)

Phone scans QR to retreive encrypted_root and address

fetch encryped_seed, iv_seed, iv_root, and hashed_password from smart contract @ address account

password = user input

password_salt = iv_seed + iv_root
check that hashed_password == hash(password, password_salt)

root = aes_decrypt(encrypted_root, iv_root, password)

keep local copy of address, encrypted_seed, iv_seed, encrypted_root, iv_root, and hashed_password

use root for all password generation